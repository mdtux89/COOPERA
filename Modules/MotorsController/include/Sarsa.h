/*
 * Copyright (C) 2013 Marco Damonte
 * CopyPolicy: Released under the terms of the LGPLv2.1 or later, see LGPL.TXT
 * Author: Marco Damonte - mdtux89@gmail.com (University of Genoa, Italy), 2013
 * Based on work of Shashank Pathak for Reinforcement Learning algorithm
 */

#ifndef SARSA_H
#define SARSA_H

#include <Configuration.h>
#include <StatesActions.h>
#include <Exploration.h>
#include <Sampler.h>

/**
 * Use Sarsa algorithm to return a optimal policy for the robot to follow.
 * The Q-table generated by the SarsaLearner module are used for this purpose.
 */
class SarsaAlgo
{
protected:

    map<int,double*>* m_Q;
    double m_alpha;
    double m_gamma;

    vector<int> next;

    int m_episodes;
    int m_length;

    bool m_isFirst;
    bool m_isRecordedState;
    bool m_reset;
    bool m_learnPhase;

    State thisState, nextState, targetState;
    vector<State> resetStates;
    Action thisAction, nextAction;
    vector<vector<int>> relevantSets;

    vector<int> initial;
    double thisReward, cumulativeReward;
    double proximity;       // wrt obstacle(s)
    double totalTimeTaken;
    double originalTime;
    double timeSinceRestart;

    Policy *explorer;
    UniformSampler uniformSampler;

    std::string rewardFileName;

    yarp::os::Port      outputQtablePort;        // a port to send learned q-table
    yarp::os::Port      inputQtablePort;         // a port to receive repaired q-table

public:

    SarsaAlgo(vector<int> initial)
    {
        rewardFileName = Config::instance()->root["Reward"]["FileName"].asString();
        this->initial = initial;
    }

    bool InitializeLearner(const std::string qFileName);

    void SetAlpha(double val)
    {
        m_alpha = val;
    }
    void SetGamma(double val)
    {
        m_gamma = val;
    }
    void SetLearnPhase(bool val)
    {
        m_learnPhase = val;
    }
    void SetEpsilon(double val)
    {
        explorer->SetEpsilon(val);
    }

    vector<int> getNext(){
        return next;
    }

    int GetEpisodeCount()
    {
        return m_episodes;
    }

    map<int,double*>* getQPtr()
    {
        return m_Q;
    }

    bool threadInit();

    void GetAction(State &s, Action &a);

    void GetReward(State &st);

    bool DoAction(State &st, Action &act);

    void run();

    void threadRelease();

    inline double norm(const yarp::sig::Vector &v)
    {
        return sqrt(yarp::math::dot(v,v));
    }    
};

#endif // SARSA_H
